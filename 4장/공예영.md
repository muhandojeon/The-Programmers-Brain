## 📚 Ch4. 복잡한 코드 읽는 방법

- 작업 기억 공간의 용량을 `인지부하`, 너무 많은 요소가 있을 때 `과부하`상태
- 인지부하의 종류: 내재적 부하, 외재적 부하, 본유적 유하
<Br>

**내재적 부하**
<Br>
문제 그 자체의 특성으로 발생 == 프로그래밍의 내재적 복잡성

**외재적 부하**
<Br>
본질적 문제 외의 추가되는 인지 부하 == 프로그래밍의 우발적 복잡성 (코드 구조나 표현 방식)
<Br><Br>

### ✔️ 인지 부하를 줄이는 기법
### 1. 리팩터링
> 코드의 유지보수보다 가독성을 우선하는 게 더 좋을 수도 있다. == 인지적 리팩터링

가독성 -> 유지보수 (충분조건) <br>
내가 생각했을 때 가독성 좋은 코드는 유지보수하기 좋은 코드지만, 역은 항상 성립하는 것은 아니다. <br>
`중복코드 제거`에만 집중하다가 오히려 요상한 추상화가 되기도 한다. <br>
'유지보수하기 좋은 코드'라는 것은 다소 추상적(목표)이지만 '읽기 쉬운 코드'라는 기준은 보다 직관적(방법)으로 느껴진다.



### 2. 생소한 언어 구성요소를 대치하기
본문에 제시한 예시들을 모두 동의하는 것은 아니지만, 짧은 코드보다 직관적인 코드가 더 좋다는 것에 공감한다.
ex) !item 보다 item == null 선호 (nullish 때문이기도), else문 피하기

<Br>

### ✔️ 과부하가 오면
1. 의존 그래프
2. 상태표

결국 둘다 손코딩과 유사한 방법인데, STM이나 작업기억공간이 부족할때 필요한 방법이다. 
조금 다른 얘기지만, 학창시절부터 아이패드로 공부하면 머리에 하나도 안들어오고 꼭 노트에 필기해야했었는데 지금도 코드 구조가 복잡하거나 이해가 안되면 a4에 흐름도(노션 안됨)를 작성해야만 머리에 들어온다.


