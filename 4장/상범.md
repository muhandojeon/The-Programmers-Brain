# 4장 복잡한 코드 읽는 방법

코드가 혼란스러운 이유는 다음 세가지임

1. STM에 저장되어 있어야 할 정보가 부족하기 때문에
2. LTM에 저장되어 있는 지식이 부족하기 때문에
3. 두뇌의 처리 능력부족

1,2번에 대해서는 2,3장에서 다뤘음   
3번 두뇌의 처리능력 부족에 대해 알아보자~   
코드가 너무 복잡하여 많은 문법 지식과 효율적인 청킹으로도 코드를 이해하기 어려울 때가 있다

## 작업 기억 공간과 STM의 차이

- 전화번호를 기억 => STM (캐시, 메인메모리)
- 두 정수를 더하는 일을 함 => 작업 기억 공간 (cpu)

STM과 같이 작업 기억 공간도 한번에 2~6개까지 기억 가능

이 용량을 **인지 부하**라고 부름

## 프로그래밍과 관련된 인지 부하의 종류
존 스웰러는 인지 부하를 세가지로 구별했다고 하네요

- 내재적 부하: 문제 자체가 얼마나 복잡한지
- 외재적 부하: 외부적 요인(문제 표현 방식 등)에 의해 문제에 복잡성이 추가된 것
  - 사람에따라 다르게 다가오며 많이 접할수록 인지 부하는 적어진다고 함
- 본유적 부하: 생각을 LTM에 저장하는 과정에서 일어나는 인지부하

인지부하를 줄이기 위해선?

## 인지 부하를 줄이기 위한 기법

대개의 경우 리팩터링은 유지보수성을 높이지만 그렇다고 가독성이 좋아지지는 않음 (e.g. 중복 코드를 하나의 메서드로 합치면, 유지보수에는 좋지만 읽을땐 매번 함수 내부 구현을 찾아봐야함)

따라서 유지보수하기 좋은 코드보다는 장기적으로 가독성이 좋도록 리팩터링을 할 수 있는데 이를 인지적 리팩터링이라고 함

이러한 인지적 리팩터링은 때때로 역 리팩터링을 수반하여 유지보수성을 낮출수도 있음

예를들어, 메서드를 인라인으로 구현할수도 있는데, 이는 유지보수성을 낮추지만 가독성은 올라감, 코드 내에서 메서드의 순서를 변경하는 방법도 있음

사람마다 리팩터링하는 내용이 다르기에 인지적 리팩터링은 자신만을 위한 리팩터링임. 많은 경우 인지적 리팩터링은 일시적이고 자신이 코드를 이해하는 것이 목적이기에 일단 이해하고 나면 코드를 원래 상태로 되돌릴수도 있음

> 실제 코드에 반영하는 방법이라면.. 낙관적으로 말하면 인지적 리팩터링은 빠른 이해와 문제 해결에 유용하지만, 현실적으로 말하면 많은 팀과 코드베이스에서 임시는 곧 영구가 된다고 생각하기 때문에 긍적적이진 않음; 임시로 내 로컬에서만 변경이면 ㅇㅈ

## 생소한 언어 구성 요소를 다른 것으로 대치하기

람다와 리스트 컴프리헨션은 간단하고 가독성 높지만, 많은 프로그래머는 익숙하지 않으며 for/while에 더 익숙하다

> for/while은 그냥 반복할 뿐이고 의도는 없는데? 람다와 리스트 컴프리헨션같이 map, filter는 이름에서 의도가 있고 변수에 넣어 의도를 더 드러내는 역할을 하는데 이래도 안쓴다고? 넌 손해좀 보자

## 작업 기억 공간에 부하가 오면 쓸 수 있는 기억 보조 수단
리팩터링만으로는 부족할 수 있음. 복잡한 구조의 코드는 두가지 방식으로 작업 기억 공간에 과부하를 유발함

- 정확히 코드의 어디를 파악해야할지 모를때 => 필요이상으로 많은 코드를 읽게 되어 작업 기억 공간의 과부하를 발생시킬 수 있음
- 코드가 서로 밀접하게 연결되어 있는 경우 두뇌는 두가지 작업을 동시에 수행함

코드를 여러번 연속해서 읽어도 이해되지 않는다면 보조 수단을 사용해보는 것도 좋은데 난 잘 모르겠음

- 의존 그래프 : 변수, 메서드, 클래스의 관계를 그래프처럼 나타낸 것
- 상태표 : 변수의 값이 코드의 각 단계별로 어떻게 변하는지 기록하는 것. 계산 로직이 복잡할 때 사용 가능

> 4장 요약: 외재적 인지부하를 줄이기 위해서 리팩터링, 구성 요소 변경, 보조 수단을 사용하여 코드를 더 잘 이해하게 만들어 보자~
